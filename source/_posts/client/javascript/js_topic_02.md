---
title: ES6 语法
date: 2019-02-19 16:14:28
tags: javascript
category: 前端
---

# let/const(常用)
let,const用于声明变量，用来替代老语法的var关键字，与var不同的是，let/const会创建一个块级作用域（通俗讲就是一个花括号内是一个新的作用域）

## 暂时性死区
使用let/const声明的变量，从一开始就形成了封闭作用域，在声明变量之前是无法使用这个变量的，这个特点也是为了弥补var的缺陷（var声明的变量有变量提升）
在预编译的阶段,JS编译器会先解析一遍判断是否有let/const声明的变量,如果在一个花括号中存在使用let/const声明的变量,则ES6规定这些变量在没声明前是无法使用的,随后再是进入执行阶段执行代码

## const
使用const关键字声明一个常量，常量的意思是不会改变的变量，const和let的一些区别是
1. const声明变量的时候必须赋值，否则会报错，同样使用const声明的变量被修改了也会报错
2. const声明变量不能改变，如果声明的是一个引用类型，则不能改变它的内存地址

# 箭头函数（常用）
ES6 允许使用箭头（=>）定义函数
箭头函数对于使用function关键字创建的函数有以下区别
1. 箭头函数没有arguments（建议使用更好的语法，剩余运算符替代）
2. 箭头函数没有prototype属性，不能用作构造函数（不能用new关键字调用）
3. 箭头函数没有自己this，它的this是词法的，引用的是上下文的this，即在你写这行代码的时候就箭头函数的this就已经和外层执行上下文的this绑定了(这里个人认为并不代表完全是静态的,因为外层的上下文仍是动态的可以使用call,apply,bind修改,这里只是说明了箭头函数的this始终等于它上层上下文中的this)

# iterator迭代器
对于可迭代的数据解构，ES6在内部部署了一个[Symbol.iterator]属性，它是一个函数，执行后会返回iterator对象（也叫迭代器对象，也叫iterator接口），拥有[Symbol.iterator]属性的对象即被视为可迭代的
默认具有iterator接口的数据结构有以下几个，注意普通对象默认是没有iterator接口的（可以自己创建iterator接口让普通对象也可以迭代）
1. Array
2. Map
3. Set
4. String
5. TypedArray（类数组）
6. 函数的 arguments 对象
7. NodeList 对象
iterator迭代器是一个对象，它具有一个next方法所以可以这么调用
next方法返回又会返回一个对象，有value和done两个属性，value即每次迭代之后返回的值，而done表示是否还需要再次循环，可以看到当value为undefined时，done为true表示循环终止

# 解构赋值（常用）
解构赋值可以直接使用对象的某个属性，而不需要通过属性访问的形式使用，对象解构原理个人认为是通过寻找相同的属性名，然后原对象的这个属性名的值赋值给新对象对应的属性

# 剩余/扩展运算符（常用）
## 扩展运算符
以数组为例,使用扩展运算符使得可以"展开"这个数组，可以这么理解，数组是存放元素集合的一个容器，而使用扩展运算符可以将这个容器拆开，这样就只剩下元素集合，你可以把这些元素集合放到另外一个数组里面
## 剩余运算符
剩余运算符最重要的一个特点就是替代了以前的arguments
访问函数的arguments对象是一个很昂贵的操作，以前的arguments.callee,arguments.caller都被废止了，建议在支持ES6语法的环境下不要在使用arguments对象，使用剩余运算符替代（箭头函数没有arguments，必须使用剩余运算符才能访问参数集合）
剩余运算符和扩展运算符的区别就是，剩余运算符会收集这些集合，放到右边的数组中，扩展运算符是将右边的数组拆分成元素的集合，它们是相反的
## 在对象中使用扩展运算符
这个是ES9的语法，ES9中支持在对象中使用扩展运算符，之前说过数组的扩展运算符原理是消耗所有迭代器，但对象中并没有迭代器，我个人认为可能是实现原理不同，但是仍可以理解为将键值对从对象中拆开，它可以放到另外一个普通对象中
## 对象属性/方法简写(常用)
es6允许当对象的属性和值相同时，省略属性名
需要注意的是
	省略的是属性名而不是值
	值必须是一个变量
## 方法简写
es6允许当一个对象的属性的值是一个函数（即是一个方法），可以使用简写的形式

# for ... of循环
for ... of是作为ES6新增的遍历方式,允许遍历一个含有iterator接口的数据结构并且返回各项的值,和ES3中的for ... in的区别如下
1. for ... of遍历获取的是对象的键值,for ... in 获取的是对象的键名
2. for ... in会遍历对象的整个原型链,性能非常差不推荐使用,而for ... of只遍历当前对象不会遍历原型链
3. 对于数组的遍历,for ... in会返回数组中所有可枚举的属性(包括原型链上可枚举的属性),for ... of只返回数组的下标对应的属性值

# Promise（常用）
Promise作为ES6中推出的新的概念，改变了JS的异步编程，现代前端大部分的异步请求都是使用Promise实现，fetch这个web api也是基于Promise的，这里不得简述一下之前统治JS异步编程的回调函数，回调函数有什么缺点，Promise又是怎么改善这些缺点
## 回调函数
众所周知，JS是单线程的，因为多个线程改变DOM的话会导致页面紊乱，所以设计为一个单线程的语言，但是浏览器是多线程的，这使得JS同时具有异步的操作，即定时器，请求，事件监听等，而这个时候就需要一套事件的处理机制去决定这些事件的顺序，即Event Loop（事件循环），这里不会详细讲解事件循环，只需要知道，前端发出的请求，一般都是会进入浏览器的http请求线程，等到收到响应的时候会通过回调函数推入异步队列，等处理完主线程的任务会读取异步队列中任务，执行回调
总结一下回调函数的一些缺点
1. 多重嵌套，导致回调地狱
2. 代码跳跃，并非人类习惯的思维模式
3. 信任问题，你不能把你的回调完全寄托与第三方库，因为你不知道第三方库到底会怎么执行回调（多次执行）
4. 第三方库可能没有提供错误处理
5. 不清楚回调是否都是异步调用的（可以同步调用ajax，在收到响应前会阻塞整个线程，会陷入假死状态，非常不推荐）
## Promise
针对回调函数这么多缺点，ES6中引入了一个新的概念Promise，Promise是一个构造函数，通过new关键字创建一个Promise的实例
Promise并不是回调函数的衍生版本，而是2个概念，所以需要将之前的回调函数改为支持Promise的版本，这个过程成为"提升"，或者"promisory"，现代MVVM框架常用的第三方请求库axios就是一个典型的例子，另外nodejs中也有bluebird，Q等
1. 多重嵌套，导致回调地狱
Promise在设计的时候引入了链式调用的概念，每个then方法同样也是一个Promise，因此可以无限链式调用下去
配合箭头函数，明显的比之前回调函数的多层嵌套优雅很多
2. 代码跳跃，并非人类习惯的思维模式
Promise使得能够同步思维书写代码，上述的代码就是先请求3000端口，得到响应后再请求3001，再请求3002，再请求3003，而书写的格式也是符合人类的思维，从先到后
3. 信任问题，你不能把你的回调完全寄托与第三方库，因为你不知道第三方库到底会怎么执行回调（多次执行）
Promise本身是一个状态机，具有pending（等待），fulfilled（成功），rejected（拒绝）这3个状态，当请求发送没有得到响应的时候为pending状态，得到响应后会resolve(决议)当前这个Promise实例,将它变为fulfilled/rejected(大部分情况会变为fulfilled),当请求发生错误后会执行reject(拒绝)将这个Promise实例变为rejected状态.一个Promise实例的状态只能从pending => fulfilled 或者从 pending => rejected，即当一个Promise实例从pending状态改变后，就不会再改变了（不存在fulfilled => rejected 或 rejected => fulfilled）
而Promise实例必须主动调用then方法，才能将值从Promise实例中取出来（前提是Promise不是pending状态），这一个“主动”的操作就是解决这个问题的关键，即第三方库做的只是把改变Promise的状态，而响应的值怎么处理，这是开发者主动控制的，这里就实现了控制反转，将原来第三方库的控制权转移到了开发者上
4. 第三方库可能没有提供错误处理
Promise的then方法会接受2个函数，第一个函数是这个Promise实例被resolve时执行的回调，第二个函数是这个Promise实例被reject时执行的回调，而这个也是开发者主动调用的
使用Promise在异步请求发送错误的时候，即使没有捕获错误，也不会阻塞主线程的代码
5. 不清楚回调是否都是异步调用的
Promise在设计的时候保证所有响应的处理回调都是异步调用的，不会阻塞代码的执行，Promise将then方法的回调放入一个叫微任务的队列中（MicroTask），保证这些回调任务都在同步任务执行完再执行.

# ES6 Module(常用)
在ES6 Module出现之前，模块化一直是前端开发者讨论的重点，面对日益增长的需求和代码，需要一种方案来将臃肿的代码拆分成一个个小模块，从而推出了AMD,CMD和CommonJs这3种模块化方案，前者用在浏览器端，后面2种用在服务端，直到ES6 Module出现
ES6 Module默认目前还没有被浏览器支持，需要使用babel，在日常写demo的时候经常会显示这个错误
可以在script标签中使用type="module"在同域的情况下可以解决（非同域情况会被同源策略拦截，webstorm会开启一个同域的服务器没有这个问题，vscode貌似不行）
## import()
关于ES6 Module静态编译的特点,导致了无法动态加载,但是总是会有一些需要动态加载模块的需求,所以现在有一个提案,使用把import作为一个函数可以实现动态加载模块,它返回一个Promise,Promise被resolve时的值为输出的模块

#函数默认值
ES6允许在函数的参数中设置默认值
## 函数默认值配合解构赋值

# Proxy
Proxy作为一个"拦截器",可以在目标对象前架设一个拦截器,他人访问对象,必须先经过这层拦截器,Proxy同样是一个构造函数,使用new关键字生成一个拦截对象的实例,ES6提供了非常多对象拦截的操作,几乎覆盖了所有可能修改目标对象的情况(Proxy一般和Reflect配套使用,前者拦截对象,后者返回拦截的结果,Proxy上有的的拦截方法Reflect都有)
## Object.definePropery
提到Proxy就不得不提一下ES5中的Object.defineProperty,这个api可以给一个对象添加属性以及这个属性的属性描述符/访问器(这2个不能共存,同一属性只能有其中一个),属性描述符有configurable,writable,enumerable,value这4个属性,分别代表是否可配置,是否只读,是否可枚举和属性的值,访问器有configurable,enumerable,get,set,前2个和属性描述符功能相同,后2个都是函数,定义了get,set后对元素的读写操作都会执行后面的getter/setter函数,并且覆盖默认的读写行为
## handler.apply
apply可以让我们拦截一个函数(JS中函数也是对象,Proxy也可以拦截函数)的执行,我们可以把它用在函数节流中
## handler.contruct
contruct可以拦截通过new关键字调用这个函数的操作,我们可以把它用在单例模式中
## handler.defineProperty
defineProperty可以拦截对这个对象的Object.defineProerty操作
注意对象内部的默认的[[SET]]操作(即对这个对象的属性赋值)会间接触发defineProperty和getOwnPropertyDescriptor这2个拦截方法

# Object.assign
这个ES6新增的Object静态方法允许我们进行多个对象的合并
可以这么理解,Object.assign遍历需要合并给target的对象(即sourece对象的集合)的属性,用等号进行赋值,这里遍历{a:1}将属性a和值数字1赋值给target对象,然后再遍历{b:2}将属性b和值数字2赋值给target对象
这里罗列了一些这个API的需要注意的知识点
1. Object.assign是浅拷贝,对于值是引用类型的属性,拷贝仍旧的是它的引用
2. 可以拷贝Symbol属性
3. 不能拷贝不可枚举的属性
4. Object.assign保证target始终是一个对象,如果传入一个基本类型,会转为基本包装类型,null/undefined没有基本包装类型,所以传入会报错
5. source参数如果是不可枚举的数据类型会忽略合并(字符串类型被认为是可枚举的,因为内部有iterator接口)
6. 因为是用等号进行赋值,如果被赋值的对象的属性有setter函数会触发setter函数,同理如果有getter函数,也会调用赋值对象的属性的getter函数(这就是为什么Object.assign无法合并对象属性的访问器,因为它会直接执行对应的getter/setter函数而不是合并它们,如果需要合并对象属性的getter/setter函数,可以使用ES7提供的Object.getOwnPropertyDescriptors和Object.defineProperties这2个API实现)
## 和ES9的对象扩展运算符对比
ES9支持在对象上使用扩展运算符,实现的功能和Object.assign相似,唯一的区别就是在含有getter/setter函数的对象的属性上有所区别
